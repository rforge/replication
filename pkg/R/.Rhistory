return(p)
}
ci2estimate(lower = 1, upper = 3)
ci2estimate(lower = 1, upper = 3, ratio = TRUE)
ci2estimate(lower = 1, upper = 3, ratio = TRUE, antilog = TRUE)
powerSignificance <- function(zo,
c = 1,
level = 0.05,
designPrior = "conditional",
alternative = "two.sided",
d = 0,
shrinkage = 1){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (min(c, na.rm = TRUE) < 0)
stop("c must be larger than 0")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
# determine direction of alternative and critical value of zr
v <- p2z(p = level, alternative = alternative)
lowertail <- ifelse(alternative == "less", TRUE, FALSE)
# determine parameters of predictive distribution of tr
if(designPrior == "conditional"){
mu <- shrinkage*zo*sqrt(c)
sigma <- 1
}
if(designPrior == "predictive"){
mu <- shrinkage*zo*sqrt(c)
sigma <- sqrt(c + 1 + 2*d*c)
}
if (designPrior == "EB"){
shrinkage <- pmax(1 - (1 + d)/zo^2, 0)
mu <- shrinkage*zo*sqrt(c)
sigma <- sqrt(shrinkage*c*(1 + d) + 1 + d*c)
}
# compute replication probability
pSig <- pnorm(q = v, mean = mu, sd = sigma, lower.tail = lowertail)
return(pSig)
}
# Target function for calculating required sample size using uniroot
ClassicalTarget <- function(c,
zo,
level = 0.05,
power,
alternative = alternative,
d = 0,
shrinkage = 1,
designPrior){
term <- powerSignificance(zo = zo, c = c, level = level,
designPrior = designPrior,
alternative = alternative,
d = d,
shrinkage = shrinkage)
return(term - power)
}
sampleSizeSignificance <- function(zo,
power,
level = 0.05,
designPrior = "conditional",
alternative = "two.sided",
d = 0,
shrinkage = 1){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (power <= 0 | power >= 1)
stop("power must be in (0, 1)")
if (level <= 0 | level >= 1)
stop("level must be in (0, 1)")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
c <- numeric()
for(i in seq_len(length(zo))){
# for conditional designPrior use analytical solution
if(designPrior == "conditional"){
u <- qnorm(p = power)
v <- p2z(level, alternative = alternative)
c <- (u + v)^2*(1/(shrinkage*zo))^2
}
# for predictive and EB designPrior use uniroot
if(designPrior %in% c("predictive", "EB")){
# compute upper bound of power
if (designPrior == "predictive") s <- shrinkage
if (designPrior == "EB") s <- pmax(1 - (1 + d)/zo[i]^2, 0)
power.limit <- pnorm(sqrt(1/(s*(1 + d) + d))*s*abs(zo[i]))
if (power > power.limit) {
power.limit.r <- floor(power.limit * 1000)/1000
stop(paste("power too large, power should not exceed",
power.limit.r))
}
# check whether desired power can be achieved for max c = 100
n.l <- 0
n.u <- 1000
target.l <- ClassicalTarget(c = n.l,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)
target.u <- ClassicalTarget(c = n.u,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)
if (sign(target.l) == sign(target.u))
if(sign(target.u)>0)
c[i] <- NA
# determine c to achieve desired power
else c[i] <- uniroot(ClassicalTarget,
lower = n.l,
upper = n.u,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)$root
}
}
return(c)
}
sampleSizeSignificance(zo = 1.96, power = 0.8, designPrior = "conditional")
p2z <- function(p,
alternative = "two.sided"){
if(any(!is.na(p)) && (min(p, na.rm = TRUE) <= 0 || max(p, na.rm = TRUE) >1))
stop("All elements of p must lie in (0,1]!")
if (!(alternative %in% c("less", "greater", "two.sided", "one.sided")))
stop('alternative must be either "less", "greater", "two.sided", or "one.sided"')
if(alternative == "two.sided")
z <- qnorm(p = p/2, lower.tail = FALSE)
if (alternative == "less")
z <- qnorm(p = p, lower.tail = TRUE)
if (alternative == "greater" | alternative == "one.sided")
z <- qnorm(p = p, lower.tail = FALSE)
return(z)
}
z2p <- function(z,
alternative = "two.sided"){
if (!(alternative %in% c("less", "greater", "two.sided", "one.sided")))
stop('alternative must be either "less", "greater", "two.sided", or "one.sided"')
if(alternative=="two.sided")
p <- 2*pnorm(abs(z), lower.tail=FALSE)
# if(alternative=="one.sided")
#     p <- pnorm(q = z, lower.tail=FALSE)
if (alternative == "less")
p <- pnorm(q = z, lower.tail = TRUE)
if (alternative == "greater" | alternative == "one.sided")
p <- pnorm(q = z, lower.tail = FALSE)
return(p)
}
sampleSizeSignificance(zo = 1.96, power = 0.8, designPrior = "conditional")
sampleSizeSignificance(zo = 1.96, power = 0.8, designPrior = "predictive")
c[i] <- NA
# Target function for calculating required sample size using uniroot
ClassicalTarget <- function(c,
zo,
level = 0.05,
power,
alternative = alternative,
d = 0,
shrinkage = 1,
designPrior){
term <- powerSignificance(zo = zo, c = c, level = level,
designPrior = designPrior,
alternative = alternative,
d = d,
shrinkage = shrinkage)
return(term - power)
}
sampleSizeSignificance <- function(zo,
power,
level = 0.05,
designPrior = "conditional",
alternative = "two.sided",
d = 0,
shrinkage = 1){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (power <= 0 | power >= 1)
stop("power must be in (0, 1)")
if (level <= 0 | level >= 1)
stop("level must be in (0, 1)")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
c <- numeric()
for(i in seq_len(length(zo))){
# for conditional designPrior use analytical solution
if(designPrior == "conditional"){
u <- qnorm(p = power)
v <- p2z(level, alternative = alternative)
c <- (u + v)^2*(1/(shrinkage*zo))^2
}
# for predictive and EB designPrior use uniroot
if(designPrior %in% c("predictive", "EB")){
# compute upper bound of power
if (designPrior == "predictive") s <- shrinkage
if (designPrior == "EB") s <- pmax(1 - (1 + d)/zo[i]^2, 0)
power.limit <- pnorm(sqrt(1/(s*(1 + d) + d))*s*abs(zo[i]))
if (power > power.limit) {
power.limit.r <- floor(power.limit * 1000)/1000
stop(paste("power too large, power should not exceed",
power.limit.r))
}
# check whether desired power can be achieved for max c = 100
n.l <- 0
n.u <- 1000
target.l <- ClassicalTarget(c = n.l,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)
target.u <- ClassicalTarget(c = n.u,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)
if (sign(target.l) == sign(target.u))
c[i] <- NA
# determine c to achieve desired power
else c[i] <- uniroot(ClassicalTarget,
lower = n.l,
upper = n.u,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)$root
}
}
return(c)
}
sampleSizeSignificance(zo = 1.96, power = 0.8, designPrior = "predictive")
powerSignificance(zo = 2, shrinkage = 1)
library(ReplicationSuccess)
powerSignificance(zo = 2, c = 1, shrinkage = 1)
powerSignificance2 <- function(zo,
c = 1,
level = 0.025,
designPrior = "conditional",
alternative = "one.sided",
d = 0,
shrinkage = 1){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (min(c, na.rm = TRUE) < 0)
stop("c must be larger than 0")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
# determine direction of alternative and critical value of zr
v <- p2z(p = level, alternative = alternative)
lowertail <- ifelse(alternative == "less", TRUE, FALSE)
if (alternative %in% c("one.sided", "two.sided")) zo  <- abs(zo)
# determine parameters of predictive distribution of tr
if(designPrior == "conditional"){
mu <- shrinkage*zo*sqrt(c)
sigma <- 1
}
if(designPrior == "predictive"){
mu <- shrinkage*zo*sqrt(c)
sigma <- sqrt(c + 1 + 2*d*c)
}
if (designPrior == "EB"){
shrinkage <- pmax(1 - (1 + d)/zo^2, 0)
mu <- shrinkage*zo*sqrt(c)
sigma <- sqrt(shrinkage*c*(1 + d) + 1 + d*c)
}
# compute replication probability
pSig <- pnorm(q = v, mean = mu, sd = sigma, lower.tail = lowertail)
# if (alternative == "two.sided") pSig + pnorm(q = -v, mean = mu, sd = sigma)
return(pSig)
}
powerSignificance2 <- function(zo,
c = 1,
level = 0.025,
designPrior = "conditional",
alternative = "one.sided",
d = 0,
shrinkage = 0){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (min(c, na.rm = TRUE) < 0)
stop("c must be larger than 0")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
# determine direction of alternative and critical value of zr
v <- p2z(p = level, alternative = alternative)
lowertail <- ifelse(alternative == "less", TRUE, FALSE)
if (alternative %in% c("one.sided", "two.sided")) zo  <- abs(zo)
# Specify shrinkage = 1 - shrinkage
shrinkage <- 1 - shrinkage
# determine parameters of predictive distribution of tr
if(designPrior == "conditional"){
mu <- shrinkage*zo*sqrt(c)
sigma <- 1
}
if(designPrior == "predictive"){
mu <- shrinkage*zo*sqrt(c)
sigma <- sqrt(c + 1 + 2*d*c)
}
if (designPrior == "EB"){
shrinkage <- pmax(1 - (1 + d)/zo^2, 0)
mu <- shrinkage*zo*sqrt(c)
sigma <- sqrt(shrinkage*c*(1 + d) + 1 + d*c)
}
# compute replication probability
pSig <- pnorm(q = v, mean = mu, sd = sigma, lower.tail = lowertail)
# if (alternative == "two.sided") pSig + pnorm(q = -v, mean = mu, sd = sigma)
return(pSig)
}
powerSignificance(zo = 2, c = 1, shrinkage = 1)
powerSignificance2(zo = 2, c = 1, shrinkage = 1)
powerSignificance2(zo = 2, c = 1, shrinkage = 0)
powerSignificance2(zo = 2, c = 1, shrinkage = 0.25)
powerSignificance(zo = 2, c = 1, shrinkage = 0.75)
?powerSignificance
powerSignificance(zo = 2, c = 1, shrinkage = 0.75)
powerSignificance(zo = 2, c = 1, shrinkage = "EB")
powerSignificance(zo = 2, c = 1, designPrior = "EB")
powerSignificance <- function(zo,
c = 1,
level = 0.025,
designPrior = "conditional",
alternative = "one.sided",
d = 0,
shrinkage = 0){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (min(c, na.rm = TRUE) < 0)
stop("c must be larger than 0")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
# determine direction of alternative and critical value of zr
v <- p2z(p = level, alternative = alternative)
lowertail <- ifelse(alternative == "less", TRUE, FALSE)
if (alternative %in% c("one.sided", "two.sided")) zo  <- abs(zo)
# determine parameters of predictive distribution of tr
if(designPrior == "conditional"){
mu <- (1-shrinkage)*zo*sqrt(c)
sigma <- 1
}
if(designPrior == "predictive"){
mu <- (1-shrinkage)*zo*sqrt(c)
sigma <- sqrt(c + 1 + 2*d*c)
}
if (designPrior == "EB"){
shrinkage <- 1 - pmax(1 - (1 + d)/zo^2, 0)
mu <- (1-shrinkage)*zo*sqrt(c)
sigma <- sqrt((1-shrinkage)*c*(1 + d) + 1 + d*c)
}
# compute replication probability
pSig <- pnorm(q = v, mean = mu, sd = sigma, lower.tail = lowertail)
# if (alternative == "two.sided") pSig + pnorm(q = -v, mean = mu, sd = sigma)
return(pSig)
}
powerSignificance(zo = 2, c = 1, shrinkage = 0.75)
powerSignificance(zo = 2, c = 1, shrinkage = 0.25)
powerSignificance(zo = 2, c = 1, designPrior = "EB")
library(ReplicationSuccess)
?powerSi
?powerSignificance
library(ReplicationSuccess)
powerSignificanceInterim
library("ReplicationSuccess")
?pIntrinsic
pIntrinsic(0.025, alternative = "one.sided", type = "Mattews")
pIntrinsic(p =0.025, alternative = "one.sided", type = "Mattews")
pIntrinsic()
pIntrinsic
pIntrinsic(p =0.025, alternative = "one.sided", type = "Matthews")
install.packages("ReplicationSuccess", repos="http://R-Forge.R-project.org")
install.packages("ReplicationSuccess", repos = "http://R-Forge.R-project.org")
install.packages("ReplicationSuccess", repos = "http://R-Forge.R-project.org")
install.packages("ReplicationSuccess", repos = "http://R-Forge.R-project.org")
res <- pIntrinsic(level, alternative = "one.sided", type = "Matthews")
if(type == "golden"){
res <- pIntrinsic(level, alternative = "one.sided", type = "Matthews")
}
res <- pIntrinsic(level, alternative = "one.sided", type = "Matthews")
library("ReplicationSuccess")
level = 0.025
res <- pIntrinsic(level, alternative = "one.sided", type = "Matthews")
res
zalpha <- qnorm(1-level)
zo <- sqrt(sqrt(5/4)-.5)*zalpha
res <- z2p(zo, alternative="one.sided")
res
thresholdSceptical <- function(level,
alternative = "one.sided",
type = "nominal"){
if (!(type %in% c("nominal", "liberal", "controlled", "golden")))
stop('type must be either "nominal", "liberal", "controlled", or "golden"')
if (!(alternative %in% c("one.sided", "two.sided")))
stop('type must be either "one.sided" or "two.sided"')
if(type == "nominal")
res <- level
if(type == "liberal")
res <- pIntrinsic(level, alternative = "one.sided", type = "Held")
if(type == "controlled"){
pI2 <- pIntrinsic(p = 2*level^2, alternative = "one.sided")
res <- pIntrinsic(p = pI2, alternative = "one.sided")
}
if(type == "golden"){
res <- pIntrinsic(level, alternative = "one.sided", type = "Matthews")
}
if(alternative == "two.sided")
res <- 2*res
return(res)
}
thresholSceptical(level = 0.025, alternatve = "one.sided", type = "controlled")
thresholdSceptical(level = 0.025, alternatve = "one.sided", type = "controlled")
thresholdSceptical(level = 0.025, alternative = "one.sided", type = "controlled")
thresholdSceptical(level = 0.025, alternative = "one.sided", type = "nominal")
thresholdSceptical(level = 0.025, alternative = "one.sided", type = "liberal")
thresholdSceptical(level = 0.025, alternative = "one.sided", type = "golden")
## new threshold included in function
thresholdSceptical <- function(level,
alternative = "one.sided",
type = "nominal"){
if (!(type %in% c("nominal", "liberal", "controlled", "powered")))
stop('type must be either "nominal", "liberal", "controlled",
of "powere
d"')
if (!(alternative %in% c("one.sided", "two.sided")))
stop('type must be either "one.sided" or "two.sided"')
if(type == "nominal")
res <- level
if(type == "liberal")
res <- 1-pnorm(qnorm(1-level)/sqrt(2))
if(type == "controlled"){
res <- 1-pnorm(qnorm(1-2*level^2)/2)
}
if(type == "powered"){
zalpha <- qnorm(1-level)
zo <- sqrt(sqrt(5/4)-.5)*zalpha
res <- z2p(zo, alternative="one.sided")
}
if(alternative == "two.sided")
res <- 2*res
return(res)
}
thresholdSceptical(level = 0.025, alternative = "one.sided", type = "golden")
thresholdSceptical(level = 0.025, alternative = "one.sided", type = "powered")
level = 0.025
pI2 <- pIntrinsic(p = 2*level^2, alternative = "one.sided")
res <- pIntrinsic(p = pI2, alternative = "one.sided")
res
res <- pIntrinsic(p = pI2, alternative = "one.sided", type = "Matthews")
level = 0.025
pI2 <- pIntrinsic(p = 2*level^2, alternative = "one.sided", type = "Matthews")
res <- pIntrinsic(p = pI2, alternative = "one.sided", type = "Matthews")
res
thresholdSceptical(level = 0.025, type = "nominal")
thresholdSceptical(level = 0.025, type = "liberal")
thresholdSceptical(level = 0.025, type = "controlled")
thresholdSceptical(level = 0.025, type = "golden")
thresholdSceptical <- function(level,
alternative = "one.sided",
type = "nominal"){
if (!(type %in% c("nominal", "liberal", "controlled", "golden")))
stop('type must be either "nominal", "liberal", "controlled", or "golden"')
if (!(alternative %in% c("one.sided", "two.sided")))
stop('type must be either "one.sided" or "two.sided"')
if(type == "nominal")
res <- level
if(type == "liberal")
res <- pIntrinsic(p = level, alternative = "one.sided", type = "Held")
if(type == "controlled"){
pI2 <- pIntrinsic(p = 2*level^2, alternative = "one.sided", type = "Held")
res <- pIntrinsic(p = pI2, alternative = "one.sided", type = "Held")
}
if(type == "golden"){
res <- pIntrinsic(p =level, alternative = "one.sided", type = "Matthews")
}
if(alternative == "two.sided")
res <- 2*res
return(res)
}
thresholdSceptical(level = 0.025, type = "nominal")
thresholdSceptical(level = 0.025, type = "liberal")
thresholdSceptical(level = 0.025, type = "controlled")
thresholdSceptical(level = 0.025, type = "golden")
