}
for (p in unique(RProjects$project)) {
data_project <- subset(RProjects, project == p)
PI <- predictionInterval(zo = data_project$to, c = data_project$c)*
data_project$se_fisr # multiplying by standard error to go to z-scale
PI <- tanh(PI) # converting back to correlation scale
within <- (data_project$r_R < PI$upper) & (data_project$r_R > PI$lower)
coverage <- mean(within)
color <- ifelse(within == TRUE, "#333333B3", "#8B0000B3")
study <- seq(1, nrow(data_project))
plot(data_project$rr, study, col = color, pch = 20,
xlim = c(-0.5, 1), xlab = expression(italic(r)[r]),
main = paste0(p, ": ", round(coverage*100, 1), "\% coverage"))
arrows(PI$lower, study, PI$upper, study, length = 0.02, angle = 90,
code = 3, col = color)
abline(v = 0, lty = 3)
}
plot(data_project$rr, study, col = color, pch = 20,
xlim = c(-0.5, 1), xlab = expression(italic(r)[r]),
main = paste0(p, ": ", round(coverage*100, 1), "\% coverage"))
arrows(PI$lower, study, PI$upper, study, length = 0.02, angle = 90,
code = 3, col = color)
abline(v = 0, lty = 3)
plot(data_project$rr, study, col = color, pch = 20,
xlim = c(-0.5, 1), xlab = expression(italic(r)[r]),
main = paste0(p, ": ", round(coverage*100, 1), " coverage"))
arrows(PI$lower, study, PI$upper, study, length = 0.02, angle = 90,
code = 3, col = color)
abline(v = 0, lty = 3)
for (p in unique(RProjects$project)) {
data_project <- subset(RProjects, project == p)
PI <- predictionInterval(zo = data_project$to, c = data_project$c)*
data_project$se_fisr # multiplying by standard error to go to z-scale
PI <- tanh(PI) # converting back to correlation scale
within <- (data_project$r_R < PI$upper) & (data_project$r_R > PI$lower)
coverage <- mean(within)
color <- ifelse(within == TRUE, "#333333B3", "#8B0000B3")
study <- seq(1, nrow(data_project))
plot(data_project$rr, study, col = color, pch = 20,
xlim = c(-0.5, 1), xlab = expression(italic(r)[r]),
main = paste0(p, ": ", round(coverage*100, 1), " coverage"))
arrows(PI$lower, study, PI$upper, study, length = 0.02, angle = 90,
code = 3, col = color)
abline(v = 0, lty = 3)
}
RProjects$zo <- with(RProjects, fiso/se_fiso)
RProjects$zr <- with(RProjects, fisr/se_fisr)
RProjects$c <- with(RProjects, se_fiso^2/se_fisr^2)
par(mfrow = c(2, 2), las = 1, mai = rep(0.65, 4))
for (p in unique(RProjects$project)) {
data_project <- subset(RProjects, project == p)
PI <- predictionInterval(zo = data_project$to, c = data_project$c)*
data_project$se_fisr # multiplying by standard error to go to z-scale
PI <- tanh(PI) # converting back to correlation scale
within <- (data_project$r_R < PI$upper) & (data_project$r_R > PI$lower)
coverage <- mean(within)
color <- ifelse(within == TRUE, "#333333B3", "#8B0000B3")
study <- seq(1, nrow(data_project))
plot(data_project$rr, study, col = color, pch = 20,
xlim = c(-0.5, 1), xlab = expression(italic(r)[r]),
main = paste0(p, ": ", round(coverage*100, 1), "\% coverage"))
arrows(PI$lower, study, PI$upper, study, length = 0.02, angle = 90,
code = 3, col = color)
abline(v = 0, lty = 3)
}
RProjects$zo <- with(RProjects, fiso/se_fiso)
RProjects$zr <- with(RProjects, fisr/se_fisr)
RProjects$c <- with(RProjects, se_fiso^2/se_fisr^2)
par(mfrow = c(2, 2), las = 1, mai = rep(0.65, 4))
for (p in unique(RProjects$project)) {
data_project <- subset(RProjects, project == p)
PI <- predictionInterval(zo = data_project$to, c = data_project$c)*
data_project$se_fisr # multiplying by standard error to go to z-scale
PI <- tanh(PI) # converting back to correlation scale
within <- (data_project$r_R < PI$upper) & (data_project$r_R > PI$lower)
coverage <- mean(within)
color <- ifelse(within == TRUE, "#333333B3", "#8B0000B3")
study <- seq(1, nrow(data_project))
plot(data_project$rr, study, col = color, pch = 20,
xlim = c(-0.5, 1), xlab = expression(italic(r)[r]),
main = paste0(p, ": ", round(coverage*100, 1), "\% coverage"))
arrows(PI$lower, study, PI$upper, study, length = 0.02, angle = 90,
code = 3, col = color)
abline(v = 0, lty = 3)
}
x11()
RProjects$zo <- with(RProjects, fiso/se_fiso)
RProjects$zr <- with(RProjects, fisr/se_fisr)
RProjects$c <- with(RProjects, se_fiso^2/se_fisr^2)
par(mfrow = c(2, 2), las = 1, mai = rep(0.65, 4))
for (p in unique(RProjects$project)) {
data_project <- subset(RProjects, project == p)
PI <- predictionInterval(zo = data_project$to, c = data_project$c)*
data_project$se_fisr # multiplying by standard error to go to z-scale
PI <- tanh(PI) # converting back to correlation scale
within <- (data_project$r_R < PI$upper) & (data_project$r_R > PI$lower)
coverage <- mean(within)
color <- ifelse(within == TRUE, "#333333B3", "#8B0000B3")
study <- seq(1, nrow(data_project))
plot(data_project$rr, study, col = color, pch = 20,
xlim = c(-0.5, 1), xlab = expression(italic(r)[r]),
main = paste0(p, ": ", round(coverage*100, 1), "\% coverage"))
arrows(PI$lower, study, PI$upper, study, length = 0.02, angle = 90,
code = 3, col = color)
abline(v = 0, lty = 3)
}
RProjects$zo <- with(RProjects, fiso/se_fiso)
RProjects$zr <- with(RProjects, fisr/se_fisr)
RProjects$c <- with(RProjects, se_fiso^2/se_fisr^2)
par(mfrow = c(2, 2), las = 1, mai = rep(0.65, 4))
for (p in unique(RProjects$project)) {
data_project <- subset(RProjects, project == p)
PI <- predictionInterval(zo = data_project$to, c = data_project$c)*
data_project$se_fisr # multiplying by standard error to go to z-scale
PI <- tanh(PI) # converting back to correlation scale
within <- (data_project$r_R < PI$upper) & (data_project$r_R > PI$lower)
coverage <- mean(within)
color <- ifelse(within == TRUE, "#333333B3", "#8B0000B3")
study <- seq(1, nrow(data_project))
plot(data_project$rr, study, col = color, pch = 20,
xlim = c(-0.5, 1), xlab = expression(italic(r)[r]),
main = paste0(p, ": ", round(coverage*100, 1), "\% coverage"))
arrows(PI$lower, study, PI$upper, study, length = 0.02, angle = 90,
code = 3, col = color)
abline(v = 0, lty = 3)
}
alphaIntrinsic <- function(alpha,
alternative = "two.sided",
type = "Held"){
z <- p2z(p = alpha, alternative = alternative)
if(type == "Held")
result <- z2p(z = sqrt(2)*z, alternative = alternative)
if(type == "Matthews")
result <- z2p(z = sqrt(2)*z/sqrt(sqrt(5) - 1), alternative = alternative)
return(result)
}
alphaIntrinsic <- function(alpha,
alternative = "two.sided",
type = "Held"){
z <- p2z(p = alpha, alternative = alternative)
if(type == "Held")
result <- z2p(z = sqrt(2)*z, alternative = alternative)
if(type == "Matthews")
result <- z2p(z = sqrt(2)*z/sqrt(sqrt(5) - 1), alternative = alternative)
return(result)
}
alphaIntrinsic(alpha= c(0.005, 0.01, 0.05))
alphaIntrinsic(alpha= c(0.005, 0.01, 0.05), alternative = "one.sided")
p2z <- function(p,
alternative = "two.sided"){
if(any(!is.na(p)) && (min(p, na.rm = TRUE) <= 0 || max(p, na.rm = TRUE) >1))
stop("All elements of p must lie in (0,1]!")
if (!(alternative %in% c("less", "greater", "two.sided", "one.sided")))
stop('alternative must be either "less", "greater", "two.sided", or "one.sided"')
if(alternative == "two.sided")
z <- qnorm(p = p/2, lower.tail = FALSE)
if (alternative == "less")
z <- qnorm(p = p, lower.tail = TRUE)
if (alternative == "greater" | alternative == "one.sided")
z <- qnorm(p = p, lower.tail = FALSE)
return(z)
}
alphaIntrinsic(alpha= c(0.005, 0.01, 0.05))
alphaIntrinsic(alpha= c(0.005, 0.01, 0.05), alternative = "one.sided")
z2p <- function(z,
alternative = "two.sided"){
if (!(alternative %in% c("less", "greater", "two.sided", "one.sided")))
stop('alternative must be either "less", "greater", "two.sided", or "one.sided"')
if(alternative=="two.sided")
p <- 2*pnorm(abs(z), lower.tail=FALSE)
# if(alternative=="one.sided")
#     p <- pnorm(q = z, lower.tail=FALSE)
if (alternative == "less")
p <- pnorm(q = z, lower.tail = TRUE)
if (alternative == "greater" | alternative == "one.sided")
p <- pnorm(q = z, lower.tail = FALSE)
return(p)
}
alphaIntrinsic(alpha= c(0.005, 0.01, 0.05))
alphaIntrinsic(alpha= c(0.005, 0.01, 0.05), alternative = "one.sided")
BFrep <- function(zo,
zr,
c = 1){
# sanity checks
if (min(c, na.rm = TRUE) < 0)
stop("c must be larger than 0")
# compute BF for H0: theta = 0 vs. H1: theta ~ N(hat(theta)_o, sigma^2_o)
bf <- dnorm(x = zr, mean = 0, sd = 1)/
dnorm(x = zr, mean = zo*sqrt(c), sd = sqrt(c + 1))
return(bf)
}
BFrep(zo = c(2, 4), zr = c(3, 3.5), c = c(1, 1.5))
BFrep(zo = c(2, 4), zr = c(3, 3.5), c = c(1, 1.5,2))
ci2p <- function(lower,
upper,
conf.level = 0.95,
ratio = FALSE,
alternative = "two.sided"){
z <- ci2z(lower = lower, upper = upper,
conf.level = conf.level, ratio = ratio)
p <- z2p(z = z, alternative = alternative)
return(p)
}
ci2estimate(lower = 1, upper = 3)
ci2estimate(lower = 1, upper = 3, ratio = TRUE)
ci2estimate(lower = 1, upper = 3, ratio = TRUE, antilog = TRUE)
ci2se <- function(lower,
upper,
conf.level = 0.95,
ratio = FALSE){
stopifnot(length(lower) == length(upper))
stopifnot(sum(lower >= upper) == 0)
level <- 1 - conf.level
q <- qnorm(p = 1 - level/2, lower.tail = TRUE)
if(ratio == TRUE){
stopifnot(sum(lower <= 0) == 0)
lower <- log(lower)
upper <- log(upper)
}
se <- (upper - lower)/(2*q)
return(se)
}
ci2estimate <- function(lower,
upper,
ratio = FALSE,
antilog = FALSE){
stopifnot(length(lower) == length(upper))
stopifnot(sum(lower >= upper) == 0)
if(ratio == TRUE){
stopifnot(sum(lower <= 0) == 0)
lower <- log(lower)
upper <- log(upper)
}
res <- (lower + upper)/2
if((ratio == TRUE) & (antilog == TRUE))
res <- exp(res)
return(res)
}
ci2z <- function(lower,
upper,
conf.level = 0.95,
ratio = FALSE){
stopifnot(length(lower) == length(upper))
stopifnot(sum(lower >= upper) == 0)
estimate <- ci2estimate(lower = lower, upper = upper, ratio = ratio)
se <- ci2se(lower = lower, upper = upper,
conf.level = conf.level, ratio = ratio)
z <- estimate/se
return(t)
}
ci2p <- function(lower,
upper,
conf.level = 0.95,
ratio = FALSE,
alternative = "two.sided"){
z <- ci2z(lower = lower, upper = upper,
conf.level = conf.level, ratio = ratio)
p <- z2p(z = z, alternative = alternative)
return(p)
}
ci2estimate(lower = 1, upper = 3)
ci2estimate(lower = 1, upper = 3, ratio = TRUE)
ci2estimate(lower = 1, upper = 3, ratio = TRUE, antilog = TRUE)
powerSignificance <- function(zo,
c = 1,
level = 0.05,
designPrior = "conditional",
alternative = "two.sided",
d = 0,
shrinkage = 1){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (min(c, na.rm = TRUE) < 0)
stop("c must be larger than 0")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
# determine direction of alternative and critical value of zr
v <- p2z(p = level, alternative = alternative)
lowertail <- ifelse(alternative == "less", TRUE, FALSE)
# determine parameters of predictive distribution of tr
if(designPrior == "conditional"){
mu <- shrinkage*zo*sqrt(c)
sigma <- 1
}
if(designPrior == "predictive"){
mu <- shrinkage*zo*sqrt(c)
sigma <- sqrt(c + 1 + 2*d*c)
}
if (designPrior == "EB"){
shrinkage <- pmax(1 - (1 + d)/zo^2, 0)
mu <- shrinkage*zo*sqrt(c)
sigma <- sqrt(shrinkage*c*(1 + d) + 1 + d*c)
}
# compute replication probability
pSig <- pnorm(q = v, mean = mu, sd = sigma, lower.tail = lowertail)
return(pSig)
}
# Target function for calculating required sample size using uniroot
ClassicalTarget <- function(c,
zo,
level = 0.05,
power,
alternative = alternative,
d = 0,
shrinkage = 1,
designPrior){
term <- powerSignificance(zo = zo, c = c, level = level,
designPrior = designPrior,
alternative = alternative,
d = d,
shrinkage = shrinkage)
return(term - power)
}
sampleSizeSignificance <- function(zo,
power,
level = 0.05,
designPrior = "conditional",
alternative = "two.sided",
d = 0,
shrinkage = 1){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (power <= 0 | power >= 1)
stop("power must be in (0, 1)")
if (level <= 0 | level >= 1)
stop("level must be in (0, 1)")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
c <- numeric()
for(i in seq_len(length(zo))){
# for conditional designPrior use analytical solution
if(designPrior == "conditional"){
u <- qnorm(p = power)
v <- p2z(level, alternative = alternative)
c <- (u + v)^2*(1/(shrinkage*zo))^2
}
# for predictive and EB designPrior use uniroot
if(designPrior %in% c("predictive", "EB")){
# compute upper bound of power
if (designPrior == "predictive") s <- shrinkage
if (designPrior == "EB") s <- pmax(1 - (1 + d)/zo[i]^2, 0)
power.limit <- pnorm(sqrt(1/(s*(1 + d) + d))*s*abs(zo[i]))
if (power > power.limit) {
power.limit.r <- floor(power.limit * 1000)/1000
stop(paste("power too large, power should not exceed",
power.limit.r))
}
# check whether desired power can be achieved for max c = 100
n.l <- 0
n.u <- 1000
target.l <- ClassicalTarget(c = n.l,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)
target.u <- ClassicalTarget(c = n.u,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)
if (sign(target.l) == sign(target.u))
if(sign(target.u)>0)
c[i] <- NA
# determine c to achieve desired power
else c[i] <- uniroot(ClassicalTarget,
lower = n.l,
upper = n.u,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)$root
}
}
return(c)
}
sampleSizeSignificance(zo = 1.96, power = 0.8, designPrior = "conditional")
p2z <- function(p,
alternative = "two.sided"){
if(any(!is.na(p)) && (min(p, na.rm = TRUE) <= 0 || max(p, na.rm = TRUE) >1))
stop("All elements of p must lie in (0,1]!")
if (!(alternative %in% c("less", "greater", "two.sided", "one.sided")))
stop('alternative must be either "less", "greater", "two.sided", or "one.sided"')
if(alternative == "two.sided")
z <- qnorm(p = p/2, lower.tail = FALSE)
if (alternative == "less")
z <- qnorm(p = p, lower.tail = TRUE)
if (alternative == "greater" | alternative == "one.sided")
z <- qnorm(p = p, lower.tail = FALSE)
return(z)
}
z2p <- function(z,
alternative = "two.sided"){
if (!(alternative %in% c("less", "greater", "two.sided", "one.sided")))
stop('alternative must be either "less", "greater", "two.sided", or "one.sided"')
if(alternative=="two.sided")
p <- 2*pnorm(abs(z), lower.tail=FALSE)
# if(alternative=="one.sided")
#     p <- pnorm(q = z, lower.tail=FALSE)
if (alternative == "less")
p <- pnorm(q = z, lower.tail = TRUE)
if (alternative == "greater" | alternative == "one.sided")
p <- pnorm(q = z, lower.tail = FALSE)
return(p)
}
sampleSizeSignificance(zo = 1.96, power = 0.8, designPrior = "conditional")
sampleSizeSignificance(zo = 1.96, power = 0.8, designPrior = "predictive")
c[i] <- NA
# Target function for calculating required sample size using uniroot
ClassicalTarget <- function(c,
zo,
level = 0.05,
power,
alternative = alternative,
d = 0,
shrinkage = 1,
designPrior){
term <- powerSignificance(zo = zo, c = c, level = level,
designPrior = designPrior,
alternative = alternative,
d = d,
shrinkage = shrinkage)
return(term - power)
}
sampleSizeSignificance <- function(zo,
power,
level = 0.05,
designPrior = "conditional",
alternative = "two.sided",
d = 0,
shrinkage = 1){
# sanity checks
if (!(designPrior %in% c("conditional", "predictive", "EB")))
stop('designPrior must be either "conditional", "predictive", or "EB"')
if (power <= 0 | power >= 1)
stop("power must be in (0, 1)")
if (level <= 0 | level >= 1)
stop("level must be in (0, 1)")
if (min(d, na.rm = TRUE) < 0)
stop("d cannot be negative")
if ((min(shrinkage, na.rm = TRUE) < 0 || max(shrinkage, na.rm = TRUE) > 1))
stop("shrinkage must be in [0, 1]")
c <- numeric()
for(i in seq_len(length(zo))){
# for conditional designPrior use analytical solution
if(designPrior == "conditional"){
u <- qnorm(p = power)
v <- p2z(level, alternative = alternative)
c <- (u + v)^2*(1/(shrinkage*zo))^2
}
# for predictive and EB designPrior use uniroot
if(designPrior %in% c("predictive", "EB")){
# compute upper bound of power
if (designPrior == "predictive") s <- shrinkage
if (designPrior == "EB") s <- pmax(1 - (1 + d)/zo[i]^2, 0)
power.limit <- pnorm(sqrt(1/(s*(1 + d) + d))*s*abs(zo[i]))
if (power > power.limit) {
power.limit.r <- floor(power.limit * 1000)/1000
stop(paste("power too large, power should not exceed",
power.limit.r))
}
# check whether desired power can be achieved for max c = 100
n.l <- 0
n.u <- 1000
target.l <- ClassicalTarget(c = n.l,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)
target.u <- ClassicalTarget(c = n.u,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)
if (sign(target.l) == sign(target.u))
c[i] <- NA
# determine c to achieve desired power
else c[i] <- uniroot(ClassicalTarget,
lower = n.l,
upper = n.u,
zo = zo[i],
level = level,
power = power,
alternative = alternative,
d = d,
shrinkage = shrinkage,
designPrior = designPrior)$root
}
}
return(c)
}
sampleSizeSignificance(zo = 1.96, power = 0.8, designPrior = "predictive")
